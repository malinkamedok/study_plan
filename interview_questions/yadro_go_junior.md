# Роман Логинов - собеседование в Ядро на Go Junior

1. Расскажите про gRPC. Как использовали на практике. Что за нумерация в прото файле у параметров входных и выходных обьектов.
2. Что такое потоки ОС. Как происходит переключение контекста у потоков ОС.
3. Как именно с точки зрения ядра ОС выполнятся программа на языке Go? (Рассказать подробно с момента как вызываем бинарь в терминале). ОС - линукс
4. Жизненный цикл процесса и потока ОС.
5. Что такое процесс демон.
6. Вызывав утилиту htop у процесса статус d - что это значит
7. Состояния процесса и потока ОС.
8. Как устроен slice. Что такое cap и len. Что такое базовый массив. Как расширяется slice.
9. Как между собой могут общаться горутины. Что такое каналы и как они работают. Зачем нужны каналы, если можно юзать общие переменные обернутые в мьютекс. Когда что лучше использовать.
10. Пакет atomic. Как атомик работает, если есть несколько ядер и как работает если одно. Как будет работать лучше?
11. Почему gRPC работает поверх именно http 2.0. Может ли в теории он работать поверх http 1.0 1.1 3.0? В чем отличие между собой версий этих протоколов.
12. Как горутина понимает, что ей нужно освободить тред? Что будет если есть 8 ядер и на восьми ядрах работают 8 горутин с бесконечным циклом который инкрементирует интовую переменную?
13. Что такое горутина. Отличие горутины от потоков ОС. Почему они легковесны?
14. Как именно использовал сваггер: сначала ручки потом дока или дока из спеки и потом ручки. Какой вариант лучше и почему?
15. Работал ли с гошным ассемблером? Работал ли просто с ассмблером если да то с каким?
16. В чем разница и почему:


    func main() {
        a1 := make([]int, 10)
        a2 := make([]int, 0, 10)
        a1 = append(a1, 1)
        a2 = append(a2, 1)
    }